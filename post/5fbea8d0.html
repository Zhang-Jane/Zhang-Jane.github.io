<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>python面试总结 | desperado</title><meta name="author" content="Jane"><meta name="copyright" content="Jane"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于python后端开发工程师https:&amp;#x2F;&amp;#x2F;blog.csdn.net&amp;#x2F;AyoCross&amp;#x2F;article&amp;#x2F;details&amp;#x2F;105294560 关于python相关面试题https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;taizilongxu&amp;#x2F;interview_python python基础相关python基"><link rel="shortcut icon" href="/img/hamburger.ico"><link rel="canonical" href="http://www.idesperado.com/post/5fbea8d0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python面试总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-05 16:48:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img2.baidu.com/it/u=4274118481,3879373441&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400" onerror="onerror=null;src='/img/unfind.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/program/nav.html"><i class="fa-fw fas fa-list"></i><span> pdf笔记</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 听音乐</span></a></li><li><a class="site-page child" href="/concert/"><i class="fa-fw fas fa-video"></i><span> 演唱会</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/extra_imgs/town.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">desperado</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/program/nav.html"><i class="fa-fw fas fa-list"></i><span> pdf笔记</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 听音乐</span></a></li><li><a class="site-page child" href="/concert/"><i class="fa-fw fas fa-video"></i><span> 演唱会</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">python面试总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-26T06:48:49.000Z" title="发表于 2020-10-26 14:48:49">2020-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-05T08:48:50.319Z" title="更新于 2023-02-05 16:48:50">2023-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="python面试总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="关于python后端开发工程师"><a href="#关于python后端开发工程师" class="headerlink" title="关于python后端开发工程师"></a>关于python后端开发工程师</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AyoCross/article/details/105294560">https://blog.csdn.net/AyoCross/article/details/105294560</a></p>
<h1 id="关于python相关面试题"><a href="#关于python相关面试题" class="headerlink" title="关于python相关面试题"></a>关于python相关面试题</h1><p><a target="_blank" rel="noopener" href="https://github.com/taizilongxu/interview_python">https://github.com/taizilongxu/interview_python</a></p>
<h1 id="python基础相关"><a href="#python基础相关" class="headerlink" title="python基础相关"></a>python基础相关</h1><h2 id="python基础的数据结构"><a href="#python基础的数据结构" class="headerlink" title="python基础的数据结构"></a>python基础的数据结构</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>可变的，无序的，不重复的。</p>
</li>
<li><p>定义用set（），不能{}。</p>
</li>
<li><p>set里面元素必须可以hash，里面的元素不可以索引。</p>
</li>
</ul>
<h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><ul>
<li>有序的元素的集合</li>
<li>元祖是不可变对象</li>
<li>元祖的定义(1,)，不能(1)</li>
<li>元祖不可变，只有读方法</li>
</ul>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li>可变的，无序的</li>
<li>key不重复且可hash</li>
<li>定义<ul>
<li>dict()</li>
<li>dict(**kwargs)</li>
<li>dict(二元结构)</li>
<li>dict.fromkeys(iterable, values)</li>
</ul>
</li>
</ul>
<h3 id="出题"><a href="#出题" class="headerlink" title="出题"></a>出题</h3><h4 id="关于定义："><a href="#关于定义：" class="headerlink" title="关于定义："></a>关于定义：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目1：</span><br><span class="line">A: tuple: a = (1)</span><br><span class="line">B: set: b = &#123;&#125;</span><br><span class="line">C: dict: c = dict(a=&quot;b&quot;)</span><br><span class="line">D: dict: d = dict(a=(1, ))</span><br><span class="line">E: dict: e = dict(a=[1,2])</span><br><span class="line"></span><br><span class="line">变形题目2：</span><br><span class="line">A: dict: b = dict&#123;(1,2):3&#125;</span><br><span class="line">B: dict: c = dict(a=(1,2))</span><br><span class="line">C: dict: d = dict(a=&#123;1,2&#125;</span><br><span class="line">D: dict: e = dict(&#123;1,2&#125;:3)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">变形题目3：</span><br><span class="line">A: dict: c = dict(zip([1,2], (3,4)))</span><br><span class="line">B: dict: d = dict(([1,2], [3,4]))</span><br><span class="line">C: dict: a = dict((1, 2), (3,4))</span><br><span class="line">D: dict: e = dict.fromkeys([1,2,3,4], 1)</span><br><span class="line"></span><br><span class="line">变形题目4：</span><br><span class="line">A: dict: c = dict.fromkeys([1,2], (3,4)))</span><br><span class="line">B: dict: d = dict.fromkeys(&#123;1:2&#125;, (3,4)))</span><br><span class="line">C: dict: a = dict.fromkeys(&quot;12&quot;, &quot;34&quot;)</span><br><span class="line">D: dict: a = dict.fromkeys(1, &quot;34&quot;)</span><br><span class="line">E: dict: e = dict.fromkeys([1,2,3,4], 1)</span><br></pre></td></tr></table></figure>

<h4 id="关于操作："><a href="#关于操作：" class="headerlink" title="关于操作："></a>关于操作：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: (1, 2) + (1, 2)</span><br><span class="line">B: (1, 2) + [1, 2]</span><br><span class="line">C: &#123;1, 2&#125; + &#123;1, 2&#125;</span><br><span class="line">D: [1, 2] + [[1,2], 2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: a, b = 1, 2 =&gt; a = 1,b = 2</span><br><span class="line">B: *a, b = 1, 2 =&gt; a = (1, ), b = 2</span><br><span class="line">C: a = 1, 2 =&gt; a = (1, 2)</span><br><span class="line">D: a, *_ = 1, 2 =&gt; a = 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: a = 1, 2, 3 =&gt; a = (1,2,3)</span><br><span class="line">B: a, *_, b = 1,2,3,4 =&gt; a = 1, _ = (2, 3), b = 4 </span><br><span class="line">C: *_, a, b = 1,2,3,4 =&gt; _ = [1, 2], a = 3, b= 4</span><br><span class="line">D: *_, a, b = (1,2,3,(4,5)) =&gt; _ = [1, 2], a = 3, b = (4, 5)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A: *_, a, b = (1,2,3,(4,5),6,[7,8]) =&gt; _ = [1,2,3,(4,5)]</span><br><span class="line">B: *_, a, b = (1,2) =&gt; _ = [1]</span><br><span class="line">C: a, *_, b = 1,2,3 =&gt; _ = [2]</span><br><span class="line">D: a, b, *_ = 1,2,3 =&gt; _ = [3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A: a, b, [] = 1, 2, 3</span><br><span class="line">B: a, b, *[a] = 1, 2, 3</span><br><span class="line">C: a, b, **&#123;&quot;a&quot;:2&#125; = 1, 2, 3</span><br><span class="line">D: a, b, c, x = 1, 2, 3, lambda x:x</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关于函数传参"><a href="#关于函数传参" class="headerlink" title="关于函数传参"></a>关于函数传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A: demo(x, y, *args, **kw):</span><br><span class="line">B: def demo(*args, x, **kw):</span><br><span class="line">C: def demo(*args, y,  **kw):</span><br><span class="line">D: def demo(*args, **kw, y):</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A: def demo(*args, y,  **kw):</span><br><span class="line">	print(args, y, kw)</span><br><span class="line">demo(1, 2, y=3)  </span><br><span class="line"></span><br><span class="line">B: def demo(*args, y,  **kw):</span><br><span class="line">	print(args, y, kw)</span><br><span class="line">demo(1,2, y=3, z=4)</span><br><span class="line"></span><br><span class="line">C:def demo(*args, y,  **kw):</span><br><span class="line">	print(args, y, kw)</span><br><span class="line">demo([1,2], 1, 2, 3, y=5, z=4)</span><br><span class="line"></span><br><span class="line">D:def demo(*args, y, **kw):</span><br><span class="line">	print(args, y, kw)</span><br><span class="line">demo([1,2], 1, a=2, 3, y=5, z=4)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def demo(x, *args, y, **kw):</span><br><span class="line">	print(x, args, y, kw)</span><br><span class="line">demo([1,2], 1, a=2, 3, y=5, z=4)</span><br><span class="line">上述的代码报错吗，不报错答案是什么？</span><br></pre></td></tr></table></figure>

<h4 id="关于生成器"><a href="#关于生成器" class="headerlink" title="关于生成器"></a>关于生成器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def coro(a):</span><br><span class="line">    print(&quot;-&gt; start : a = &quot;, a)</span><br><span class="line">    b = yield a+1</span><br><span class="line">    print(&quot;-&gt; recive : b &quot;, b)</span><br><span class="line">    c = yield a+b</span><br><span class="line">    print(&quot;-&gt; recive : c &quot;, c)</span><br><span class="line">    d = yield</span><br><span class="line">    print(&quot;-&gt; recive : d &quot;, d)</span><br><span class="line">    yield</span><br><span class="line">a = coro(1)</span><br><span class="line">next(a)</span><br><span class="line">next(a)</span><br><span class="line">输出怎么样的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def coro(a):</span><br><span class="line">    print(&quot;-&gt; start : a = &quot;, a)</span><br><span class="line">    b = yield a+1</span><br><span class="line">    print(&quot;-&gt; recive : b &quot;, b)</span><br><span class="line">    c = yield a+b</span><br><span class="line">    print(&quot;-&gt; recive : c &quot;, c)</span><br><span class="line">    d = yield</span><br><span class="line">    print(&quot;-&gt; recive : d &quot;, d)</span><br><span class="line">    yield</span><br><span class="line">a = coro(1)</span><br><span class="line">next(a)</span><br><span class="line">a.send(2)</span><br><span class="line">next(a)</span><br><span class="line">输出怎么样的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def coro(a):</span><br><span class="line">    print(&quot;-&gt; start : a = &quot;, a)</span><br><span class="line">    b = yield a+1</span><br><span class="line">    print(&quot;-&gt; recive : b &quot;, b)</span><br><span class="line">    c = yield a+b</span><br><span class="line">    print(&quot;-&gt; recive : c &quot;, c)</span><br><span class="line">    d = yield</span><br><span class="line">    print(&quot;-&gt; recive : d &quot;, d)</span><br><span class="line">    yield</span><br><span class="line">a = coro(1)</span><br><span class="line">next(a)</span><br><span class="line">a.send(2)</span><br><span class="line">a.send(3)</span><br><span class="line">输出怎么样的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def coro(a):</span><br><span class="line">    print(&quot;-&gt; start : a = &quot;, a)</span><br><span class="line">    b = yield a+1</span><br><span class="line">    print(&quot;-&gt; recive : b &quot;, b)</span><br><span class="line">    c = yield a+b</span><br><span class="line">    print(&quot;-&gt; recive : c &quot;, c)</span><br><span class="line">    d = yield</span><br><span class="line">    print(&quot;-&gt; recive : d &quot;, d)</span><br><span class="line">    yield</span><br><span class="line">a = coro(1)</span><br><span class="line">next(a)</span><br><span class="line">a.send(2)</span><br><span class="line">next(a)</span><br><span class="line">a.send(3)</span><br><span class="line">next(a)</span><br><span class="line">输出怎么样的结果</span><br></pre></td></tr></table></figure>

<h2 id="Python-直接赋值、浅拷贝和深度拷贝解析"><a href="#Python-直接赋值、浅拷贝和深度拷贝解析" class="headerlink" title="Python 直接赋值、浅拷贝和深度拷贝解析"></a>Python 直接赋值、浅拷贝和深度拷贝解析</h2><ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">clist = copy.copy(alist)</span><br><span class="line">clist[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line">alist[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明，c浅拷贝的a的对象引用，当c改变的时候不会改变a，当a改变的时候会影响c</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">clist = copy.deepcopy(alist)</span><br><span class="line">clist[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line">alist[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值语句</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]]</span><br><span class="line">clist = alist</span><br><span class="line">clist[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line">alist[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="built_in">print</span>(clist)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>]]</span><br></pre></td></tr></table></figure>



<h2 id="类-class-和元类-metaclass-的有什么区别？"><a href="#类-class-和元类-metaclass-的有什么区别？" class="headerlink" title="类 class 和元类 metaclass 的有什么区别？"></a>类 class 和元类 metaclass 的有什么区别？</h2><p>类和元类的区别：</p>
<ul>
<li>类的目的是用来来创建实例对象</li>
<li>元类的目的是用来创建类（元类是最底层的东西，是所有类的父类）</li>
</ul>
<p>类：由于类是由元类创建得到的，因此我们可以认为类的本质是一个对象，既然类是一个对象，我们就可以像操作对象一样操作一个类：可以将类赋值给一个变量、可以复制这个类、可以为其添加属性等等。</p>
<p>元类我们实际开发使用并不需要考虑和使用它。</p>
<h2 id="实例方法、类方法和静态方法有什么不同？"><a href="#实例方法、类方法和静态方法有什么不同？" class="headerlink" title="实例方法、类方法和静态方法有什么不同？"></a>实例方法、类方法和静态方法有什么不同？</h2><p>实例方法、类方法和静态方法，都是属于类的方法，不同点就是传入的参数和调用的方式。</p>
<p>三种方法传入的参数分别是：self（实例化对象）、cls（类本身）、无参数</p>
<p>三种方法的调用方式：</p>
<ul>
<li>实例方法：由对象调用；至少一个 self 参数；执行实例方法时，自动将调用该方法的实例化对象赋值给 self；实例化方法中可以修改实例的属性</li>
<li>类方法：由类调用；至少一个 cls 参数；执行类方法时，自动将调用该方法的类赋值给 cls；类方法中可以修改类的属性</li>
<li>静态方法：由类调用；无默认参数；内部使用；</li>
<li>静态方法特殊性：静态方法不需要传入实例或者类，它是用来被类内部普通方法或类方法使用的一种方法</li>
</ul>
<h2 id="类中的-property-属性有什么作用？"><a href="#类中的-property-属性有什么作用？" class="headerlink" title="类中的 property 属性有什么作用？"></a>类中的 property 属性有什么作用？</h2><ul>
<li>property 属性的定义有两种方式：装饰器和类属性</li>
<li>通过调用 property 属性，可以简化获取数据的流程</li>
<li>property 属性目的：优化代码，简化代码，调用 @property 装饰的方法可以获得一个属性，调用该方法写法和调用实例属性一样</li>
</ul>
<p>参考代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个属性的特殊方法,并且参数只有一个self，有一个返回值</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化对象</span></span><br><span class="line">obj = Person(<span class="string">&quot;Felix&quot;</span>)</span><br><span class="line"><span class="comment"># 调用实例属性</span></span><br><span class="line">name = obj.name</span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用property属性，方法后面的括号不能写</span></span><br><span class="line"><span class="comment"># 这样就类似于调用实例中的一个属性</span></span><br><span class="line">ret = obj.age <span class="comment"># 结果就是方法的返回值</span></span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Felix</span></span><br><span class="line"><span class="comment"># 28</span></span><br></pre></td></tr></table></figure>

<h2 id="类如何才能支持比较操作？"><a href="#类如何才能支持比较操作？" class="headerlink" title="类如何才能支持比较操作？"></a>类如何才能支持比较操作？</h2><ul>
<li>使用运算符重载</li>
<li>@total_ordering 类装饰器可以根据类中定义的，小于方法和等于方法自己进行推测</li>
</ul>
<p>参考代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        self.w = w</span><br><span class="line">        self.h = h</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.w * self.h</span><br><span class="line">    <span class="comment"># &lt; 运算符重载</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in__lt__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.area() &lt; other.area()</span><br><span class="line">    <span class="comment"># &lt;= 运算符重载</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;in__le__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.area() &lt;= other.area()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个矩形实例</span></span><br><span class="line">r1 = Rectangle(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">r2 = Rectangle(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(r1 &lt; r2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<h2 id="hasattr-、getattr-、setattr-、delattr-分别有什么作用？"><a href="#hasattr-、getattr-、setattr-、delattr-分别有什么作用？" class="headerlink" title="hasattr()、getattr()、setattr()、delattr()分别有什么作用？"></a>hasattr()、getattr()、setattr()、delattr()分别有什么作用？</h2><ul>
<li>hasattr(object,name)：判断一个函数是否有name属性或者方法，返回布尔值</li>
<li>getattr(object, name)：获取对象的属性</li>
<li>setattr(object, name, values)：赋值给对象的属性，如果该属性不存在，则先创建该对象，然后赋值</li>
<li>delattr(object, name, values)：删除对象的属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">func</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Felix&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断属性或方法是否存在</span></span><br><span class="line">func = func()</span><br><span class="line">res = <span class="built_in">hasattr</span>(func, <span class="string">&quot;name&quot;</span>) <span class="comment"># 判断对象是否有name属性，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(func, <span class="string">&quot;run&quot;</span>) <span class="comment"># 判断对象是否有run方法，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(func, <span class="string">&quot;age&quot;</span>) <span class="comment"># 判断对象是否有age属性，False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性</span></span><br><span class="line">func = func()</span><br><span class="line"><span class="built_in">getattr</span>(func, <span class="string">&quot;name&quot;</span>) <span class="comment"># 获取name属性，Felix</span></span><br><span class="line"><span class="built_in">getattr</span>(func, <span class="string">&quot;age&quot;</span>)  <span class="comment"># 获取不存在的属性，出现错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置属性</span></span><br><span class="line">func= func()</span><br><span class="line">res = <span class="built_in">hasattr</span>(func, <span class="string">&quot;age&quot;</span>) <span class="comment"># 判断age属性是否存在，False</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">setattr</span>(func, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>) <span class="comment"># 对age属性进行赋值，无返回值</span></span><br><span class="line">res1 = <span class="built_in">hasattr</span>(func, <span class="string">&quot;age&quot;</span>) <span class="comment"># 再次判断属性是否存在，True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除属性</span></span><br><span class="line"><span class="built_in">delattr</span>(func, <span class="string">&#x27;name&#x27;</span>) <span class="comment"># 返回值None</span></span><br></pre></td></tr></table></figure>

<h2 id="大文件只需读取部分内容，或者避免读取时候内存不足的解决方法？"><a href="#大文件只需读取部分内容，或者避免读取时候内存不足的解决方法？" class="headerlink" title="大文件只需读取部分内容，或者避免读取时候内存不足的解决方法？"></a>大文件只需读取部分内容，或者避免读取时候内存不足的解决方法？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># islice返回一个生成器函数，进行切片操作,取出索引为101到105的值</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filetest.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> islice(f, <span class="number">101</span>, <span class="number">105</span>):</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> islice(f, <span class="number">5</span>): <span class="comment">#只给一个参数，指定的是结束的位置</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<h2 id="什么是上下文？with-上下文管理器原理？"><a href="#什么是上下文？with-上下文管理器原理？" class="headerlink" title="什么是上下文？with 上下文管理器原理？"></a>什么是上下文？with 上下文管理器原理？</h2><p>with 方法常用于打开文件，使用 with 方法打开文件后可以自动关闭文件，即使打开或者使用文件时出现了错误，文件也可以正常关闭。</p>
<p>什么是上下文（context）？</p>
<ul>
<li>context 其实说白了，和一篇文章中的上下文是一个意思，在通俗一点，我觉得叫环境更好。</li>
<li>上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是为了叫的好听叫上下文。</li>
<li>进程中断在操作系统中是有上有下的，不过不这个高深的问题就不要深究了</li>
<li>任何实现了 <strong>enter</strong>() 和 <strong>exit</strong>() 方法的对象都可以称之为上下文管理器，上下文管理器对象可以使用with关键字。显然，文件（file）对象也实现了上下文管理器。</li>
</ul>
<p>那么文件对象是如何实现这两个方法的呢？我们可以模拟实现一个自己的文件类，让该类实现 <strong>enter</strong>() 和 <strong>exit</strong>() 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件管理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename, mode</span>):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开文件的方法，返回我们打开的对象，也就是传入的文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;entering&quot;</span>)</span><br><span class="line">        self.f = <span class="built_in">open</span>(self.filename, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭文件的方法，不用我们自己手动去关闭文件对象了</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;will exit&quot;</span>)</span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> File(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;writing&quot;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;hello, world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="什么是全缓冲、行缓冲和无缓冲？"><a href="#什么是全缓冲、行缓冲和无缓冲？" class="headerlink" title="什么是全缓冲、行缓冲和无缓冲？"></a>什么是全缓冲、行缓冲和无缓冲？</h2><ul>
<li>全缓冲：Python 中默认的缓冲区是 4096 字节，当缓冲区里面的空间占满后，就将数据写入到磁盘中。</li>
<li>行缓冲：当写入的数据，每遇到换行符，就将缓冲中的数据写入到磁盘中。</li>
<li>无缓冲：无缓冲，顾名思义就是一写入数据，就将数据写入到磁盘中。</li>
<li>三种缓冲，可以通过 buffering 参数进行设置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python中默认的缓冲区(全缓冲)是4096字节</span></span><br><span class="line"><span class="comment"># buffering可以设置缓冲字节大小，当写入的数据超过设置值，才会写入到文件中</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;001_测试缓冲案例文件.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, buffering=<span class="number">2048</span>)</span><br><span class="line"><span class="comment"># 写入3个字节，打开txt文件为空</span></span><br><span class="line">f.write(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment"># 写入2045个字节，总共2048个，还是为空</span></span><br><span class="line">f.write(<span class="string">&#x27;*&#x27;</span> * <span class="number">2045</span>)</span><br><span class="line"><span class="comment"># 此时我们在写入一个字节，就由缓冲存储到磁盘了，此时打开txt文件就可以看见数据了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行缓冲： buffering=1</span></span><br><span class="line"><span class="comment"># f = open(&#x27;001_测试缓冲案例文件.txt&#x27;, &#x27;w&#x27;, buffering=1)</span></span><br><span class="line"><span class="comment"># f.write(&#x27;abc&#x27;)</span></span><br><span class="line"><span class="comment"># 只要遇到换行符，就将缓存存到磁盘</span></span><br><span class="line"><span class="comment"># f.write(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无缓冲：buffering=0</span></span><br><span class="line"><span class="comment"># 写入数据就直接存储到磁盘</span></span><br></pre></td></tr></table></figure>

<h2 id="什么是序列化和反序列化？JSON-序列化时常用的四个函数是什么？"><a href="#什么是序列化和反序列化？JSON-序列化时常用的四个函数是什么？" class="headerlink" title="什么是序列化和反序列化？JSON 序列化时常用的四个函数是什么？"></a>什么是序列化和反序列化？JSON 序列化时常用的四个函数是什么？</h2><p><strong>什么是序列化</strong>：我们程序中的变量和对象（比如文字、图片等内容），在传输的时候需要使用二进制数据，将这些变量或对象转换为二进制数据的过程，就是序列化。</p>
<p><strong>什么是反序列化</strong>：反序列化就是序列化的逆过程，把获取的二进制数据重建为变量或对象。实际序列化和反序列化就是二进制数据和原始数据格式之间的一个转换过程。</p>
<p><strong>JSON 中常用的四个函数</strong>：</p>
<ul>
<li>json.dump：将数据序列化到文件中</li>
<li>json.load：将文件中的内容反序列化读取出来</li>
<li>json.dumps：将 Python 格式转化为 JSON 的字符串形式（序列化）</li>
<li>json.loads：将 JSON 的字符串格式转换为 Python 的数据格式（反序列化）</li>
<li>上面容易混淆，记住 load 是下载的意思，就是将 JSON 的读取出来或者转换为 Python 的数据格式；dump 是倾倒，意思就是把数据放进去，正好和 load 相反。</li>
</ul>
<p>注意：标准 JSON 格式数据要使用双引号。</p>
<h2 id="Python-的内存管理机制是什么？"><a href="#Python-的内存管理机制是什么？" class="headerlink" title="Python 的内存管理机制是什么？"></a>Python 的内存管理机制是什么？</h2><p>内存管理机制：引用计数、垃圾回收、内存池。</p>
<p>引用计数：引用计数是对变量引用次数的一种标记手段，对象被引用时，我们对其计数增加 1，当该对象不被引用时，我们对其计数减去 1，如果计数变成了 0，说明该对象没有被引用，此时我们就可以删除该对象。</p>
<p>垃圾回收：Python 中有三种垃圾回收机制，其中引用计数为主，还有标记清除和分代回收。</p>
<p>内存池：</p>
<p>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放<br>内存池（memory pool）的概念：<br>当创建大量消耗小内存的对象时，频繁调用new&#x2F;malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是  预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>内存池的实现方式有很多，性能和适用范围也不一样。<br>Python中的内存管理机制——Pymalloc：<br>Python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new&#x2F;malloc的行为来申请内存空间。<br>关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作</p>
<h2 id="常用库，xpath，正则表达式"><a href="#常用库，xpath，正则表达式" class="headerlink" title="常用库，xpath，正则表达式"></a>常用库，xpath，正则表达式</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h5 id="match、search-和-findall-有什么区别？"><a href="#match、search-和-findall-有什么区别？" class="headerlink" title="match、search 和 findall 有什么区别？"></a><strong>match、search 和 findall 有什么区别？</strong></h5><ul>
<li>match 从字符串的开始进行匹配，如果字符串第一个字符不符合匹配规则，则匹配失败，函数返回 None 值；</li>
<li>search 从字符串左侧开始，然后向右匹配字符串，当找到第一个匹配，匹配结束；</li>
<li>findall 查找整个字符串，返回所有的匹配结果，匹配结果是一个列表。</li>
</ul>
<h3 id="正则表达式的-、-、-分别代表什么意思？"><a href="#正则表达式的-、-、-分别代表什么意思？" class="headerlink" title="正则表达式的 ()、[]、{} 分别代表什么意思？"></a>正则表达式的 ()、[]、{} 分别代表什么意思？</h3><ul>
<li><code>()</code>：匹配的的字符串进行分组，目的是为了提取匹配的字符串。表达式中有几个 <code>()</code> 就有几个相应的匹配字符串, 一个 <code>()</code> 代表一个组。</li>
<li><code>[]</code>：定义匹配的字符范围，匹配多个数字多个字母等, 匹配中括号任何一个都可以，类似或或或… 比如 <code>[a-zA-Z0-9]</code> 表示匹配字母和数字。<code>[\s*]</code> 表示空格或者 <code>*</code> 号。（注意：中括号里面的所有表达式只匹配一个就结束，中括号只代表一个字符。要匹配多个后面使用 <code>+</code> 号）</li>
<li><code>&#123;&#125;</code>：一般用来定义匹配的长度，只限制 <code>&#123;&#125;</code> 它前面的一个字符，比如 <code>\d&#123;3&#125;</code> 表示匹配三个数字，<code>\d&#123;1,3&#125;</code> 表示匹配一到三个数字，包括 1 和 3。</li>
</ul>
<h3 id="正则表达式中的-、-、-、-有什么区别？"><a href="#正则表达式中的-、-、-、-有什么区别？" class="headerlink" title="正则表达式中的 .\*、.+、.\*?、.+? 有什么区别？"></a>正则表达式中的 <code>.\*</code>、<code>.+</code>、<code>.\*?</code>、<code>.+?</code> 有什么区别？</h3><ul>
<li><code>*</code> 匹配 0 个或多个的表达式，贪婪模式</li>
<li><code>+</code> 匹配 1 个或多个的表达式，非贪婪</li>
<li><code>?</code> 匹配 0 个或 1 个由问好前面字符或者表达式，非贪婪方式</li>
<li><code>.*</code>：贪婪匹配，找到满足条件的最大匹配</li>
<li><code>.+</code>：贪婪匹配，找到满足条件的最大匹配</li>
<li><code>.*?</code>：非贪婪，找到满足条件的最小匹配</li>
<li><code>.+?</code>：非贪婪，找到满足条件的最小匹配</li>
</ul>
<h1 id="http协议相关"><a href="#http协议相关" class="headerlink" title="http协议相关"></a>http协议相关</h1><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p>http&#x3D;tcp+80，https&#x3D;tcp+443</p>
<p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p>
<p>　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<h2 id="HTTP1-0和1-1的区别"><a href="#HTTP1-0和1-1的区别" class="headerlink" title="HTTP1.0和1.1的区别"></a>HTTP1.0和1.1的区别</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/52d86558ca57">https://www.jianshu.com/p/52d86558ca57</a></p>
<h1 id="scrapy的框架"><a href="#scrapy的框架" class="headerlink" title="scrapy的框架"></a>scrapy的框架</h1><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><p>Scrapy 主要有 5 大部件和 2 个中间件。</p>
<ul>
<li><strong>Scrapy Engine（引擎）</strong>：负责 Spider、ItemPipeline、Downloader、Scheduler 中间的通讯，信号、数据传递等</li>
<li><strong>Scheduler（调度器）</strong>：它负责接受引擎发送过来的 Request 请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎</li>
<li><strong>Downloader（下载器）</strong>：负责下载 Scrapy Engine（引擎）发送的所有 Requests 请求，并将其获取到的 Responses 交还给 Scrapy Engine（引擎），由引擎交给 Spider 来处理</li>
<li><strong>Spider（爬虫）</strong>：它负责处理所有 Responses，从中分析提取数据，获取 Item 字段需要的数据，并将需要跟进的 URL 提交给引擎，再次进入 Scheduler（调度器）</li>
<li><strong>Item Pipeline（管道）</strong>：它负责处理 Spider 中获取到的 Item，并进行进行后期处理（详细分析、过滤、存储等）的地方</li>
<li><strong>Downloader Middlewares（下载中间件）</strong>：你可以当作是一个可以自定义扩展下载功能的组件</li>
<li><strong>Spider Middlewares（Spider 中间件）</strong>：你可以理解为是一个可以自定扩展和操作引擎和 Spider 中间通信的功能组件（比如进入 Spider 的 Responses，和从 Spider 出去的 Requests）</li>
</ul>
<h2 id="Scrapy-是如何实现去重的？指纹去重是什么？"><a href="#Scrapy-是如何实现去重的？指纹去重是什么？" class="headerlink" title="Scrapy 是如何实现去重的？指纹去重是什么？"></a>Scrapy 是如何实现去重的？指纹去重是什么？</h2><ul>
<li>Scrapy 配置文件里面有个 dont_filter 参数，设置 False 就是开启去重，默认值就是 False；</li>
<li>调度器会根据每一次的 URL 请求，对请求的相关信息进行加密，加密后的信息存储在一个集合之中，如果有新的请求，加密后和集合中已有的信息进行对比，如果已经存在，则改请求就淘汰，以此实现去重。</li>
</ul>
<h2 id="Scrapy-项目中的常用命令有哪些？"><a href="#Scrapy-项目中的常用命令有哪些？" class="headerlink" title="Scrapy 项目中的常用命令有哪些？"></a>Scrapy 项目中的常用命令有哪些？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject（创建一个爬虫项目）</span><br><span class="line">scrapy crawl XX（运行 XXX 爬虫项目）</span><br><span class="line">scrapy shell http://www.hao123.cn（调试网址为 http://www.hao123.cn 的网站）</span><br><span class="line">scrapy version 查看版本信息</span><br><span class="line">scrapy list 查看爬虫信息，显示目录所有的爬虫</span><br></pre></td></tr></table></figure>

<h2 id="描述一下-Scrapy-爬取一个网站的工作流程？"><a href="#描述一下-Scrapy-爬取一个网站的工作流程？" class="headerlink" title="描述一下 Scrapy 爬取一个网站的工作流程？"></a>描述一下 Scrapy 爬取一个网站的工作流程？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. Engine获得从爬行器中爬行的初始请求。</span><br><span class="line">2. Engine在调度程序中调度请求，并请求下一次抓取请求。</span><br><span class="line">3. 调度程序将下一个请求返回到引擎。</span><br><span class="line">4. 引擎将请求发送到下载器，通过下载器中间件（请参阅process_request()）。</span><br><span class="line">5. 页面下载完成后，下载器生成一个响应(带有该页面)并将其发送给引擎，通过下载器中间件(请参阅process_response())。</span><br><span class="line">6. 引擎从下载加载程序接收响应，并将其发送给Spider进行处理，并通过Spider中间件(请参阅process_spider_input())。</span><br><span class="line">7. Spider处理响应，并向引擎返回报废的项和新请求(要跟踪的)，通过Spider中间件(请参阅process_spider_output())。</span><br><span class="line">8. 引擎将已处理的项目发送到项目管道，然后将已处理的请求发送到调度程序，并请求可能的下一个请求进行抓取。</span><br><span class="line">9. 这个过程重复(从第1步)，直到调度程序不再发出请求。</span><br><span class="line"></span><br><span class="line">简单总结：</span><br><span class="line">start_request（引擎）&gt;调度器&gt;引擎&gt;(下载中间件)&gt;下载器&gt;(下载中间件)&gt;引擎&gt;(爬虫中间件)&gt;爬虫&gt;(爬虫中间件)&gt;引擎&gt;管道&amp;&amp;调度器&gt; more</span><br></pre></td></tr></table></figure>

<h2 id="Spider、CrawlSpider、XMLFeedSpider-和-RedisSpider-有什么区别？"><a href="#Spider、CrawlSpider、XMLFeedSpider-和-RedisSpider-有什么区别？" class="headerlink" title="Spider、CrawlSpider、XMLFeedSpider 和 RedisSpider 有什么区别？"></a>Spider、CrawlSpider、XMLFeedSpider 和 RedisSpider 有什么区别？</h2><ul>
<li>Spider：scrapy.Spider, 是所有 Spider 的基类，它是最基础的爬虫，所有的 spider 都会继承 scrapy.Spider。它提供了 start_requests() 的默认实现，读取并请求 spider 属性中的 start_urls，并根据返回的 response 调用 spider 中的 parse 方法。</li>
<li>CrawlSpider：scrapy.spiders.CrawlSpider，规则爬虫，提供了一个新的属性 rules，该属性是一个包含一个或多个 Rule 对象的集合，每个 Rule 对爬取网站的动作定义了特定的规则。</li>
<li>XMLFeedSpider：scrapy.spiders.XMLFeedSpider 设计用于通过迭代各个节点来分析 XML 源。</li>
<li>RedisSpider：scrapy_redis.spiders.RedisSpider,scrapy-redis 是 Scrapy 框架基于 Redis 数据库的组件，用于 scrapy 项目的分布式开发和部署，可以方便的进行分布式爬取和数据处理。</li>
</ul>
<h2 id="Scrapy如何爬取属性在不同页面的item呢"><a href="#Scrapy如何爬取属性在不同页面的item呢" class="headerlink" title="Scrapy如何爬取属性在不同页面的item呢"></a>Scrapy如何爬取属性在不同页面的item呢</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">通过response的meta来进行传递，字典键值对。不但是item，就算是一些自定义参数也可以传。</span><br><span class="line"></span><br><span class="line">Request.meta special keys</span><br><span class="line">The Request.meta attribute can contain any arbitrary data, but there are some special keys recognized by Scrapy and its built-in extensions.</span><br><span class="line"></span><br><span class="line">Those are:</span><br><span class="line"></span><br><span class="line">dont_redirect</span><br><span class="line"></span><br><span class="line">dont_retry</span><br><span class="line"></span><br><span class="line">handle_httpstatus_list</span><br><span class="line"></span><br><span class="line">handle_httpstatus_all</span><br><span class="line"></span><br><span class="line">dont_merge_cookies</span><br><span class="line"></span><br><span class="line">cookiejar</span><br><span class="line"></span><br><span class="line">dont_cache</span><br><span class="line"></span><br><span class="line">redirect_reasons</span><br><span class="line"></span><br><span class="line">redirect_urls</span><br><span class="line"></span><br><span class="line">bindaddress</span><br><span class="line"></span><br><span class="line">dont_obey_robotstxt</span><br><span class="line"></span><br><span class="line">download_timeout</span><br><span class="line"></span><br><span class="line">download_maxsize</span><br><span class="line"></span><br><span class="line">download_latency</span><br><span class="line"></span><br><span class="line">download_fail_on_dataloss</span><br><span class="line"></span><br><span class="line">proxy</span><br><span class="line"></span><br><span class="line">ftp_user (See FTP_USER for more info)</span><br><span class="line"></span><br><span class="line">ftp_password (See FTP_PASSWORD for more info)</span><br><span class="line"></span><br><span class="line">referrer_policy</span><br><span class="line"></span><br><span class="line">max_retry_times</span><br></pre></td></tr></table></figure>

<h2 id="Scrapy爬虫有内存泄露-x2F-内存爆了-x2F-栈溢出了，怎么办"><a href="#Scrapy爬虫有内存泄露-x2F-内存爆了-x2F-栈溢出了，怎么办" class="headerlink" title="Scrapy爬虫有内存泄露&#x2F;内存爆了&#x2F;栈溢出了，怎么办?"></a>Scrapy爬虫有内存泄露&#x2F;内存爆了&#x2F;栈溢出了，怎么办?</h2><p><a target="_blank" rel="noopener" href="https://docs.scrapy.org/en/latest/topics/leaks.html?highlight=trackref">https://docs.scrapy.org/en/latest/topics/leaks.html?highlight=trackref</a></p>
<ol>
<li>首先检查编写的中间件，管道(pipeline) 或扩展。例如，在 spider_opened 中分配资源但在 spider_closed 中没有释放它们。</li>
<li>检查是否出现下载速度和管道存储速度是否平衡，如果差距很大，会造成队列积压。</li>
<li>使用 trackref 在telNet下调试内存泄露，具体问题具体分析，其追踪了所有活动(live)的Request, Item及Selector对象的引用。</li>
<li>使用 get_oldest() 方法来看都是什么鬼东西在那卡半天，找出来单独测试然后寻找解决办法。</li>
<li>使用Pympler模块监测python对象</li>
</ol>
<h2 id="cookiejar使用以及作用"><a href="#cookiejar使用以及作用" class="headerlink" title="cookiejar使用以及作用"></a>cookiejar使用以及作用</h2><p>There is support for keeping multiple cookie sessions per spider by using the <a target="_blank" rel="noopener" href="https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#std-reqmeta-cookiejar"><code>cookiejar</code></a> Request meta key. By default it uses a single cookie jar (session), but you can pass an identifier to use different ones.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i, url in enumerate(urls):</span><br><span class="line">    yield scrapy.Request(url, meta=&#123;&#x27;cookiejar&#x27;: i&#125;,</span><br><span class="line">        callback=self.parse_page)</span><br></pre></td></tr></table></figure>

<p>Keep in mind that the <a target="_blank" rel="noopener" href="https://docs.scrapy.org/en/latest/topics/downloader-middleware.html#std-reqmeta-cookiejar"><code>cookiejar</code></a> meta key is not “sticky”. You need to keep passing it along on subsequent requests. For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parse_page(self, response):</span><br><span class="line">    # do some processing</span><br><span class="line">    return scrapy.Request(&quot;http://www.example.com/otherpage&quot;,</span><br><span class="line">        meta=&#123;&#x27;cookiejar&#x27;: response.meta[&#x27;cookiejar&#x27;]&#125;,</span><br><span class="line">        callback=self.parse_other_page)</span><br></pre></td></tr></table></figure>

<h2 id="ItemLoader的用法"><a href="#ItemLoader的用法" class="headerlink" title="ItemLoader的用法"></a>ItemLoader的用法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zwq912318834/article/details/79530828">https://blog.csdn.net/zwq912318834/article/details/79530828</a></p>
<h1 id="kafka消息队列"><a href="#kafka消息队列" class="headerlink" title="kafka消息队列"></a>kafka消息队列</h1><p>在Kafka有几个比较重要的概念：</p>
<ul>
<li><p>broker</p>
<p>  用于标识每一个Kafka服务，当然同一台服务器上可以开多个broker,只要他们的broker id不相同即可</p>
</li>
<li><p>Topic</p>
<p>  消息主题，从逻辑上区分不同的消息类型</p>
</li>
<li><p>Partition</p>
<p>  用于存放消息的队列，存放的消息都是有序的，同一主题可以分多个partition，如分多个partiton时，同样会以如partition1存放1,3,5消息,partition2存放2,4,6消息。</p>
</li>
<li><p>Produce</p>
<p>  消息生产者，生产消息，可指定向哪个topic，topic哪个分区中生成消息。</p>
</li>
<li><p>Consumer</p>
<p>  消息消费者，消费消息，同一消息只能被同一个consumer group中的consumer所消费。consumer是通过offset进行标识消息被消费的位置。当然consumer的个数取决于此topic所划分的partition，如同一group中的consumer个数大于partition的个数，多出的consumer将不会处理消息。</p>
</li>
</ul>
<ol>
<li>在订阅消费模式下（c.subscribe([‘mytopic’])），kafka保证每条消息在同一个Consumer Group中只会被某一个Consumer消费，就是同一个组下面的Consumer，A消费了，B就不会消费。</li>
<li>一个消费者可以同时消费多个topic</li>
<li>消费者的数量应不多于该topic分区的数量，否则多余的消费者必定无法收到消息</li>
<li>多个消费者，消费同一个分区，消费到的数据由生产的发往那个分区决定的</li>
<li>在设置一个分区的时候，生产和消费的顺序是一致的，因为只有一个分区。而设置多个分区时，消费获取分区时候是无序的，因此导致生产和消费之间顺序不一致。<strong>分区之间是无序的，分区内的消息是有序的。</strong></li>
<li>为了解决多个分区导致的生产与消费之间的顺序不一致，我们需要向指定的分区生产以及消费</li>
</ol>
<h1 id="关系型数据库和非关系型数据库的区别"><a href="#关系型数据库和非关系型数据库的区别" class="headerlink" title="关系型数据库和非关系型数据库的区别"></a>关系型数据库和非关系型数据库的区别</h1><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>采用了关系模型来组织的数据库。关系模型指的是二维的表格。</p>
<ul>
<li><strong>数据库</strong>：包括一个或多个表</li>
<li><strong>表（关系 Relation）</strong>：是以列和行的形式组织起来的数据的集合</li>
<li><strong>列（属性 Attribute）</strong>：在数据库中经常被称为字段</li>
<li><strong>行（值组 Tuple）</strong>：在数据库中经常被称为记录</li>
</ul>
<h4 id="关系型数据库优点"><a href="#关系型数据库优点" class="headerlink" title="关系型数据库优点"></a>关系型数据库优点</h4><ul>
<li><strong>事务一致性</strong>：通过事务处理保持数据的一致性</li>
<li><strong>复杂查询</strong>：支持SQL，可以进行 JOIN 等复杂查询</li>
<li><strong>容易理解</strong>：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
<li><strong>使用方便</strong>：通用的 SQL 语言使得操作关系型数据库非常方便</li>
<li><strong>易于维护</strong>：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</li>
</ul>
<h4 id="关系型数据库缺点"><a href="#关系型数据库缺点" class="headerlink" title="关系型数据库缺点"></a>关系型数据库缺点</h4><ul>
<li><strong>读写性能</strong>：在数据量达到一定规模时，由于关系型数据库的系统逻辑非常复杂，为了维护一致性，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重</li>
<li><strong>表结构更新</strong>：表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂</li>
<li><strong>高并发</strong>：网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈</li>
<li><strong>海量数据</strong>：对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的</li>
</ul>
<h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>非关系型数据库（NoSQL）是对不同于传统的关系数据库的数据库管理系统的统称。</p>
<p>可以参考如下：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903654869172232">https://juejin.im/post/6844903654869172232</a></p>
<h1 id="Mysql，redis"><a href="#Mysql，redis" class="headerlink" title="Mysql，redis"></a>Mysql，redis</h1><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="Innodb和Myisam的区别"><a href="#Innodb和Myisam的区别" class="headerlink" title="Innodb和Myisam的区别"></a>Innodb和Myisam的区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Innodb存储引擎    mysql5.6之后的默认的存储引擎</span><br><span class="line">数据和索引存储在一起 2个文件</span><br><span class="line">    数据索引\表结构</span><br><span class="line">数据持久化</span><br><span class="line">支持事务   : 为了保证数据的完整性,将多个操作变成原子性操作   : 保持数据安全</span><br><span class="line">支持行级锁 : 修改的行少的时候使用                          : 修改数据频繁的操作</span><br><span class="line">支持表级锁 : 批量修改多行的时候使用                        : 对于大量数据的同时修改</span><br><span class="line">支持外键   : 约束两张表中的关联字段不能随意的添加\删除      : 能够降低数据增删改的出错率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Myisam存储引擎    mysql5.5之前的默认的存储引擎</span><br><span class="line">数据和索引不存储在一起  3个文件</span><br><span class="line">    数据\索引\表结构</span><br><span class="line">数据持久化</span><br><span class="line">只支持表锁</span><br><span class="line"></span><br><span class="line">InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>MyISAM不支持事务，InnoDB支持事务。由于MyISAM在很长一段时间内是MySQL的默认存储引擎，所以在很多人的印象中MySQL是不支持事务的数据库。实际上，InnoDB是一个性能良好的事务性引擎。它实现了四个标准的隔离级别，默认的隔离级别为可重复读（REPEATABLE READ），并通过间隙锁策略来防止幻读的出现。此外它还通过多版本并发控制（MVCC）来支持高并发。</p>
</li>
<li><p>对表的行数查询的支持不同。MyISAM内置了一个计数器来存储表的行数。执行 select count(<em>) 时直接从计数器中读取，速度非常快。而InnoDB不保存这些信息，执行 select count(</em>)需要全表扫描。当表中数据量非常大的时候速度很慢。</p>
</li>
<li><p>锁的粒度不同。MyISAM仅支持表锁。每次操作锁住整张表。这种处理方式一方面加锁的开销比较小，且不会出现死锁，但另一方面并发性能较差。InnoDB支持行锁。每次操作锁住一行数据，一方面行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源，速度较慢，且可能发生死锁，但是另一方面由于锁的粒度较小，发生锁冲突的概率也比较低，并发性较好。此外，即使是使用了InnoDB存储引擎，但如果MySQL执行一条sql语句时不能确定要扫描的范围，也会锁住整张表。</p>
</li>
<li><p>对主键的要求不同。MyISAM允许没有主键的表存在。而如果在建表时没有显示的指定主键，InnoDB就会为每一行数据自动生成一个6字节的ROWID列，并以此做为主键。这种主键对用户不可见。InnoDB对主键采取这样的策略是与它的数据和索引的组织方式有关的，下文会讲到。</p>
</li>
<li><p>数据和索引的组织方式不同。MyISAM将索引和数据分开进行存储。索引存放在.MYI文件中，数据存放在.MYD文件中。索引中保存了相应数据的地址。以表名+.MYI文件分别保存。 InnoDB的主键索引树的叶子节点保存主键和相应的数据。其它的索引树的叶子节点保存的是主键。也正是因为采取了这种存储方式，InnoDB才强制要求每张表都要有主键。</p>
</li>
<li><p>对AUTO_INCREMENT的处理方式不一样。如果将某个字段设置为INCREMENT，InnoDB中规定必须包含只有该字段的索引。但是在MyISAM中，也可以将该字段和其他字段一起建立联合索引。</p>
</li>
<li><p>delete from table的处理方式不一样。MyISAM会重新建立表。InnoDB不会重新建立表，而是一行一行的删除。因此速度非常慢。推荐使用truncate table，不过需要用户有drop此表的权限。</p>
</li>
<li><p>MyISAM崩溃后无法安全恢复，InnoDB支持崩溃后的安全恢复。InnoDB实现了一套完善的崩溃恢复机制，保证在任何状态下(包括在崩溃恢复状态下)数据库挂了，都能正常恢复。</p>
</li>
<li><p>MyISAM不支持外键，InnoDB支持外键。</p>
</li>
<li><p>缓存机制不同。MyISAM仅缓存索引信息，而不缓存实际的数据信息。而InnoDB不仅缓存索引信息，还会缓存数据信息。其将数据文件按页读取到缓冲池，然后按最近最少使用的算法来更新数据。</p>
</li>
</ol>
<h3 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h3><ul>
<li>原子性（Atomicity）：要么全部被执行成功，要么就全部不被执行</li>
<li>一致性（Consistency）：事务执行以后，数据库从一种状态转换为另一种状态。</li>
<li>隔离性（Isolation）：事务在成功之前，处于隔离状态，事务不会受到外界的影响。</li>
<li>持久性（Durability）：事务成功之后，状态就永久保存，数据的状态不会发生改变，事务提交后出现其它错误，事务的处理结果也会得到保存。</li>
</ul>
<h3 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h3><ul>
<li>第一范式（1NF）：列具有原子性，一列不能再分成几列</li>
<li>第二范式（2NF）：表必须具有主键，如果有列没有包含在主键之中，那么这些列必须依赖于主键，并且不能只依赖于主键的一部分。</li>
<li>第三范式（3NF）：非主键列必须直接依赖于主键，不能使用传递依赖。比如以下间接依赖不被允许：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键。</li>
</ul>
<h3 id="SQL-语句主要有哪些？分别有什么作用？"><a href="#SQL-语句主要有哪些？分别有什么作用？" class="headerlink" title="SQL 语句主要有哪些？分别有什么作用？"></a>SQL 语句主要有哪些？分别有什么作用？</h3><ul>
<li>DQL：数据查询语言，查询数据，如 select</li>
<li>DML：数据操作语言，增加、修改、删除数据，如 insert、udpate、delete</li>
<li>TPL：事务处理语言，处理事务，包括 begin transaction、commit、rollback</li>
<li>DCL：数据控制语言，进行授权与权限回收，如 grant、revoke</li>
<li>DDL：数据定义语言，管理数据库和数据表，如 create、drop</li>
<li>CCL：指针控制语言，通过指针对表进行操作，如 declare cursor</li>
</ul>
<h3 id="什么是索引？索引的优缺点是什么？"><a href="#什么是索引？索引的优缺点是什么？" class="headerlink" title="什么是索引？索引的优缺点是什么？"></a>什么是索引？索引的优缺点是什么？</h3><ul>
<li>索引：索引是数据表的引用指针，它是表空间的一个组成部分。类似于一本书的目录。</li>
<li>索引目的：增加数据库的查询速度，索引类似一个目录，查询数据时候直接查询索引，大大提高查询的效率。</li>
<li>索引的优缺点：提高数据库查询速度，创建数据时候，也需要创建对应的索引，降低了数据写入的速度，此外建立大量的索引，也会占用大量的磁盘空间。</li>
</ul>
<h3 id="什么是视图？视图有什么作用？"><a href="#什么是视图？视图有什么作用？" class="headerlink" title="什么是视图？视图有什么作用？"></a>什么是视图？视图有什么作用？</h3><ul>
<li>视图是根据查询结果返回的一张虚拟的表，用于数据查询对比。</li>
<li>视图是一条 SELECT 语句被执行后返回的结果，返回的结果就是一张表，该表就是视图。</li>
<li>视图并会存储具体的数据，当数据库里面的数据发生变化以后，视图同时也会发生变化。</li>
</ul>
<p>视图的作用：</p>
<ul>
<li>视图可以简化用户的查询操作</li>
<li>视图可以方便的对比数据</li>
<li>视图为数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
</ul>
<h3 id="如何进行-SQL-优化？"><a href="#如何进行-SQL-优化？" class="headerlink" title="如何进行 SQL 优化？"></a>如何进行 SQL 优化？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 从搭建数据库的角度上来描述问题</span><br><span class="line"># 建表的角度上</span><br><span class="line">    # 1.合理安排表关系</span><br><span class="line">    # 2.尽量把固定长度的字段放在前面</span><br><span class="line">    # 3.尽量使用char代替varchar</span><br><span class="line">    # 4.分表: 水平分,垂直分</span><br><span class="line"># 使用sql语句的时候</span><br><span class="line">    # 1.尽量用where来约束数据范围到一个比较小的程度,比如说分页的时候</span><br><span class="line">    # 2.尽量使用连表查询而不是子查询</span><br><span class="line">    # 3.删除数据或者修改数据的时候尽量要用主键作为条件</span><br><span class="line">    # 4.合理的创建和使用索引</span><br><span class="line">        # 1.查询的条件字段不是索引字段</span><br><span class="line">            # 对哪一个字段创建了索引,就用这个字段做条件查询</span><br><span class="line">        # 2.在创建索引的时候应该对区分度比较大的列进行创建</span><br><span class="line">            # 1/10以下的重复率比较适合创建索引</span><br><span class="line">        # 3.范围</span><br><span class="line">            # 范围越大越慢</span><br><span class="line">            # 范围越小越快</span><br><span class="line">            # like &#x27;a%&#x27;  快</span><br><span class="line">            # like &#x27;%a&#x27;  慢</span><br><span class="line">        # 4.条件列参与计算/使用函数</span><br><span class="line">        # 5.and和or</span><br><span class="line">            # id name</span><br><span class="line">            # select * from s1 where id = 1800000 and name = &#x27;eva&#x27;;</span><br><span class="line">            # select count(*) from s1 where id = 1800000 or name = &#x27;eva&#x27;;</span><br><span class="line">            # 多个条件的组合,如果使用and连接</span><br><span class="line">                # 其中一列含有索引,都可以加快查找速度</span><br><span class="line">            # 如果使用or连接</span><br><span class="line">                # 必须所有的列都含有索引,才能加快查找速度</span><br><span class="line">        # 6.联合索引 : 最左前缀原则(必须带着最左边的列做条件,从出现范围开始整条索引失效)</span><br><span class="line">            # (id,name,email)</span><br><span class="line">            # select * from s1 where id = 1800000 and name = &#x27;eva&#x27; and email = &#x27;eva1800000@oldboy&#x27;;</span><br><span class="line">            # select * from s1 where id = 1800000 and name = &#x27;eva&#x27;;</span><br><span class="line">            # select * from s1 where id = 1800000 and email = &#x27;eva1800000@oldboy&#x27;;</span><br><span class="line">            # select * from s1 where id = 1800000;</span><br><span class="line">            # select * from s1 where name = &#x27;eva&#x27; and email = &#x27;eva1800000@oldboy&#x27;;</span><br><span class="line">            # (email,id,name)</span><br><span class="line">            # select * from s1 where id &gt;10000 and email = &#x27;eva1800000@oldboy&#x27;;</span><br><span class="line">        # 7.条件中写出来的数据类型必须和定义的数据类型一致</span><br><span class="line">            # select * from biao where name = 666   # 不一致</span><br><span class="line">        # 8.select的字段应该包含order by的字段</span><br><span class="line">            # select name,age from 表 order by age;  # 比较好</span><br><span class="line">            # select name from 表 order by age;  # 比较差</span><br><span class="line"></span><br><span class="line">什么是最左前缀原则？什么是最左匹配原则</span><br><span class="line">顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</span><br><span class="line">最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span><br><span class="line">=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</span><br></pre></td></tr></table></figure>



<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-常见数据类型有哪些？各自有什么应用场景？"><a href="#Redis-常见数据类型有哪些？各自有什么应用场景？" class="headerlink" title="Redis 常见数据类型有哪些？各自有什么应用场景？"></a>Redis 常见数据类型有哪些？各自有什么应用场景？</h3><ul>
<li>常见的数据类型一共 5 种：String、Hash、List、Set、Sorted set</li>
<li>String：最常用的数据类型，用于网站计数，排名，粉丝数量等</li>
<li>Hash：field 和 value 的一个映射表，一般用于存储对象，常用于存储各种信息</li>
<li>List：类似于列表，和列表一样支持查找和遍历，常用于消息列表，网站的分页也可以使用</li>
<li>Set：set 功能和 List 类似，但是它可以排除重复的数据，并且和集合一样，可以进行交集、并集、差集的操作。比如可以用于 QQ 好友的 DNA 分析，是否有共同好友等等。</li>
<li>Sorted set：有序集合，常用于网站的排行榜。</li>
</ul>
<h3 id="Redis-的事务是什么？"><a href="#Redis-的事务是什么？" class="headerlink" title="Redis 的事务是什么？"></a>Redis 的事务是什么？</h3><p>NoSQL 数据库对事务支持性能不太完善，但是 Redis 支持原子操作和隔离操作。</p>
<p>Redis 通过 MULTI、EXEC、WATCH 等一系列的命令来实现事务（transaction）功能。</p>
<p>Redis 事务是一些列 Redis 命令的集合：它是一个单独的隔离操作，事物中的命令队列都会按顺序全部执行，不会被外来事物干扰；事物的执行具有原子性，事务中的命令要么全部执行成功，要么全部都不执行。</p>
<p>Redis 事物执行过程：开始事务、命令入队、执行事务。</p>
<h3 id="redis-有哪几种数据淘汰策略？"><a href="#redis-有哪几种数据淘汰策略？" class="headerlink" title="redis 有哪几种数据淘汰策略？"></a>redis 有哪几种数据淘汰策略？</h3><p>Redisn 内存淘汰，我们首先需要设置 server.maxmemory，该参数表示可以使用最大的内存。当内存达到设置值后就开始淘汰数据。</p>
<p>内存淘汰策略种类：</p>
<ol>
<li>volatile-lru: 从设置了过期时间的数据中，选择近期最少使用数据进行删除</li>
<li>volatile-ttr: 从设置了过期时间的数据中，选择即将过期的数据进行删除</li>
<li>volatile-random: 从设置了过期时间的数据中，中随机选择数据进行删除</li>
<li>allkeys-lru: 从所有数据中，选择最少使用的数据进行删除，</li>
<li>allkeys-random: 从所有数据中，随机选择数据删除</li>
<li>no-eviction：严禁删除数据，新的数据写入时候没有空间，就会报错</li>
</ol>
<h3 id="如何解决-Redis-的并发竞争-Key-的问题？"><a href="#如何解决-Redis-的并发竞争-Key-的问题？" class="headerlink" title="如何解决 Redis 的并发竞争 Key 的问题？"></a>如何解决 Redis 的并发竞争 Key 的问题？</h3><ul>
<li>大量请求同时取请求一个 key，导致最终的结果和我们预想的结果不同，就是并发竞争 Key。</li>
<li>针对并发竞争 key 的问题，实际开发使用分布式锁应对。推荐使用 ZooKeeper 和 Redis 来实现分布式锁。但是使用锁的缺点会降低 Redis 的性能。如果不存在竞争，最好不要使用。</li>
</ul>
<h3 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h3><p>分布式锁是解决并发访问共享资源的一种方法。分布式锁具有互斥性，同一时间只能有一个访问客户拥有锁，锁超时以后，会自动释放锁，防止出现死锁。锁设计时候要支持非阻塞和阻塞。</p>
<p>分布式锁的实现方案</p>
<ul>
<li>数据库实现（乐观锁）</li>
<li>基于 ZooKeeper 的实现</li>
<li>基于 Redis 的实现（推荐）</li>
</ul>
<h3 id="Python-如何实现一个-Redis-分布式锁"><a href="#Python-如何实现一个-Redis-分布式锁" class="headerlink" title="Python 如何实现一个 Redis 分布式锁"></a>Python 如何实现一个 Redis 分布式锁</h3><p>Redis 分布式锁应该具备哪些条件：</p>
<ul>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行</li>
<li>高可用的获取锁与释放锁</li>
<li>高性能的获取锁与释放锁</li>
<li>具备可重入特性</li>
<li>具备锁失效机制，防止死锁</li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</li>
</ul>
<p>选用 Redis 实现分布式锁原因：</p>
<ul>
<li>Redis 有很高的性能</li>
<li>Redis 命令对此支持较好，实现起来比较方便</li>
</ul>
<p>使用命令介绍：</p>
<p>SETNX</p>
<ul>
<li>SETNX key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。</li>
</ul>
<p>expire</p>
<ul>
<li>expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。</li>
</ul>
<p>delete</p>
<ul>
<li>delete key：删除 key, 在使用 Redis 实现分布式锁的时候，主要就会使用到这三个命令。</li>
</ul>
<p>Redis 分布式锁实现思想（Redis 实现分布式锁主要使用 Redis 单线程的对 key 原子操作特性）：</p>
<ul>
<li>获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID（Universally Unique Identifier，翻译为中文是通用唯一识别码，UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息），通过此值在释放锁的时候进行判断。</li>
<li>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</li>
<li>释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">import uuid</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class RedisLock():</span><br><span class="line"></span><br><span class="line">    def __init__(self, lock_name, time_out, acquire_time):</span><br><span class="line">        <span class="comment"># 连接redis数据库</span></span><br><span class="line">        self.redis_client = redis.StrictRedis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=6379, db=0)</span><br><span class="line">        self.lock_name = lock_name   <span class="comment"># 锁的名称(锁的唯一ID)</span></span><br><span class="line">        self.time_out = time_out  <span class="comment"># 锁的超时时间(超过时间，自动释放锁)</span></span><br><span class="line">        self.acquire_time = acquire_time  <span class="comment"># 获取锁的时间(超过时间，放弃获取锁)</span></span><br><span class="line"></span><br><span class="line">    def acquire_lock(self):</span><br><span class="line">        <span class="string">&#x27;&#x27;</span><span class="string">&#x27;获取一个分布式锁&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 生成一个唯一的uuid值作为锁(键)的值(补充：UUID，Universally Unique Identifier，翻译为中文是通用唯一识别码，UUID 的目的是让分布式系统中的所有元素都能有唯一的识别信息)</span></span><br><span class="line">        identifier = str(uuid.uuid4())</span><br><span class="line">        end = time.time() + self.acquire_time</span><br><span class="line">        lock = <span class="string">&#x27;string:lock:&#x27;</span> + self.lock_name</span><br><span class="line">        <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">            <span class="comment"># 设置一个锁，设置锁的名称和唯一的UUID值</span></span><br><span class="line">            <span class="keyword">if</span> self.redis_client.setnx(lock, identifier):</span><br><span class="line">                <span class="comment"># 给锁设置超时时间，防止进程崩溃导致其它进程无法获取锁</span></span><br><span class="line">                self.redis_client.expire(lock, self.time_out)</span><br><span class="line">                <span class="built_in">return</span> identifier</span><br><span class="line">            <span class="keyword">elif</span> not self.redis_client.ttl(lock): <span class="comment"># ttl获取锁的生存时间</span></span><br><span class="line">                self.redis_client.expire(lock, self.time_out)</span><br><span class="line">            time.sleep(0.001)</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">    def release_lock(self, identifier):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;通用的锁释放函数&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        lock = <span class="string">&quot;string:lock:&quot;</span> + self.lock_name</span><br><span class="line">        pip = self.redis_client.pipeline(True)</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            try:</span><br><span class="line">                pip.watch(lock)</span><br><span class="line">                <span class="comment"># 获取锁的值，即设置锁时的UUID值</span></span><br><span class="line">                lock_value = self.redis_client.get(lock)</span><br><span class="line">                <span class="keyword">if</span> not lock_value:</span><br><span class="line">                    <span class="built_in">return</span> True</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> lock_value.decode() == identifier:</span><br><span class="line">                    pip.multi()</span><br><span class="line">                    pip.delete(lock)</span><br><span class="line">                    pip.execute()</span><br><span class="line">                    <span class="built_in">return</span> True</span><br><span class="line">                pip.unwatch()</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            except redis.exceptions.WatchError:</span><br><span class="line">                pass</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    redis_lock = RedisLock(lock_name=<span class="string">&#x27;lock001&#x27;</span>, time_out=10, acquire_time=10)</span><br></pre></td></tr></table></figure>

<h1 id="布隆过滤原理"><a href="#布隆过滤原理" class="headerlink" title="布隆过滤原理"></a>布隆过滤原理</h1><p>布隆过滤器通过引入 K 个相互独立的哈希函数，将元素进行哈希后，然后进行元素判重的过程。</p>
<p>相对于一般算法，具有极高的空间效率和极快的查询效率，缺点是<strong>有一定的误判率（极低）</strong>和<strong>删除困难</strong>。</p>
<p>一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p>
<p>Bloom-Filter 核心思想是多个哈希函数，降低误判率，只要有一个 hash 值不在集合之中，就可以判断元素步骤集合之中。布隆过滤器一般用于大量数据去重判断，比如爬虫去重。</p>
<h3 id="存入过程"><a href="#存入过程" class="headerlink" title="存入过程"></a><strong>存入过程</strong></h3><ul>
<li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li>
<li>这些K个hash值映射到对应的K个二进制的数组下标</li>
<li>将K个下标对应的二进制数据改成1。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>
<h1 id="frida和xposed的区别"><a href="#frida和xposed的区别" class="headerlink" title="frida和xposed的区别"></a>frida和xposed的区别</h1><h3 id="Xposed-的原理"><a href="#Xposed-的原理" class="headerlink" title="Xposed 的原理"></a>Xposed 的原理</h3><p>Android基于Linux，第一个启动的进程自然是<code>init进程</code>，该进程会启动所有Android进程的父进程——<code>Zygote(孵化)进程</code>，该进程的启动配置在<code>/init.rc</code>脚本中，而Zygote进程对应的执行文件是<code>/system/bin/app_process</code>，该文件完成类库的加载以及一些函数的调用工作。在Zygote进程创建后，再fork出SystemServer进程和其他进程。而Xposed Framework呢，就是<strong>用自己实现的app_process替换掉了系统原本提供的app_process</strong>，加载一个额外的jar包，然后入口从原来的<code>com.android.internal.osZygoteInit.main()</code>被替换成了<code>de.robv.android.xposed.XposedBridge.main()</code>，然后<strong>创建的Zygote进程就变成Hook的Zygote进程了</strong>，而后面Fork出来的进程也是被Hook过的。这个Jar包在<code>/data/data/de.rbov.android.xposed.installer/bin/XposedBridge.jar</code>。</p>
<h3 id="frida注入原理"><a href="#frida注入原理" class="headerlink" title="frida注入原理"></a>frida注入原理</h3><p>Frida的核心是用C编写的，并将<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://developers.google.com/v8/">Google的V8引擎</a>注入到目标进程中，在这些进程中，JS可以完全访问内存，挂钩函数甚至调用进程内的本机函数来执行。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils.decorator <span class="keyword">import</span> cal_time</span><br><span class="line"><span class="comment"># li = [100, 89 , 98, 23, 76, 38, 85, 12, 9, 0, 4]</span></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="comment"># print(li)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间复杂度n^2</span></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bubble_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils.decorator <span class="keyword">import</span> cal_time</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">列表分为有序区和无序区域(这俩个区域都在同一个列表进行操作)，俩个部分，最初有序的区域只要一个元素</span></span><br><span class="line"><span class="string">每次从无序的区域哪一个插入到有序的区域的位置，直到最后</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">li = [<span class="number">100</span>, <span class="number">2</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">23</span>, <span class="number">76</span>, <span class="number">38</span>, <span class="number">85</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间复杂度O(n^2)</span></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):  <span class="comment"># 摸到的牌的下标从1开始，代表摸到牌的下标，第0个默认是最开始的有序的区域</span></span><br><span class="line">        tmp = li[i]  <span class="comment"># 摸到的牌的值，先存起来</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># 代表的是剩下的牌的下标</span></span><br><span class="line">        <span class="comment"># 往后移动牌的条件：拿到的牌要比待插入的有序的区域中的值小。j&gt;=0表示的已经到有序区域最小值，再往前走没有比较的值了</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; li[j]:</span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 在循环结束的位置，要么-1（已经到头了），要么li[j]（有序区域的值都比摸到的牌的值小，就是说你不用插入，往后插入）</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="comment"># print(li)</span></span><br><span class="line">insert_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">li = [<span class="number">100</span>, <span class="number">2</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">23</span>, <span class="number">76</span>, <span class="number">38</span>, <span class="number">85</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">获取最小值的位置</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_min_pos</span>(<span class="params">li</span>):</span><br><span class="line">    min_pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt; li[min_pos]:</span><br><span class="line">            min_pos = i</span><br><span class="line">    <span class="keyword">return</span> li[min_pos]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        min_pos = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_pos]:</span><br><span class="line">                min_pos = j</span><br><span class="line">        li[i], li[min_pos] = li[min_pos], li[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select_sort(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">from utils.decorator import cal_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert_sort(li, d):</span><br><span class="line">    for i in range(d, len(li)):  # 摸到的牌的下标从1开始，代表摸到牌的下标，第0个默认是最开始的有序的区域</span><br><span class="line">        tmp = li[i]  # 摸到的牌的值，先存起来</span><br><span class="line">        j = i - d  # 代表的是剩下的牌的下标</span><br><span class="line">        # 往后移动牌的条件：拿到的牌要比待插入的有序的区域中的值小。j&gt;=0表示的已经到有序区域最小值，再往前走没有比较的值了</span><br><span class="line">        while j &gt;= 0 and tmp &lt; li[j]:</span><br><span class="line">            li[j + d] = li[j]</span><br><span class="line">            j -= d</span><br><span class="line">        # 在循环结束的位置，要么-1（已经到头了），要么li[j]（有序区域的值都比摸到的牌的值小，就是说你不用插入，往后插入）</span><br><span class="line">        li[j + d] = tmp</span><br><span class="line"></span><br><span class="line">@cal_time</span><br><span class="line">def shell_sort(li):</span><br><span class="line">    d = len(li) // 2</span><br><span class="line">    while d &gt; 0:</span><br><span class="line">        insert_sort(li, d)</span><br><span class="line">        d = d // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = list(range(10000))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"># print(li)</span><br><span class="line">shell_sort(li)</span><br><span class="line"># print(li)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">100</span>, <span class="number">2</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">23</span>, <span class="number">76</span>, <span class="number">38</span>, <span class="number">85</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort2</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    tmp = li[<span class="number">0</span>]</span><br><span class="line">    left_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> x &lt;= tmp]</span><br><span class="line">    right_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> x &gt; tmp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick_sort2(left_list) + [tmp] + quick_sort2(right_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = quick_sort2(li)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">li, left, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    注意：快速排序是直接在原始数组里进行各种交换操作，所以当子数组被分割出来的时候，原始数组里的排列也被改变了</span></span><br><span class="line"><span class="string">    :param li: 所要排序的列表</span></span><br><span class="line"><span class="string">    :param left: 排序的区域的</span></span><br><span class="line"><span class="string">    :param right: 排序的区域的</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left &lt; right <span class="keyword">and</span> <span class="built_in">len</span>(li) &gt;= <span class="number">2</span>:</span><br><span class="line">        mid = partition1(li, left, right)</span><br><span class="line">        quick_sort(li, left, mid - <span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">li, left, right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.找一个基准值（可以是固定，可以是随机的）</span></span><br><span class="line"><span class="string">    2.根据这个基准值，分成俩部分，一部分比他大的放右边，比他小的放左边</span></span><br><span class="line"><span class="string">    3.最后把这个基准值放回到空缺的位置，然后返回</span></span><br><span class="line"><span class="string">    :param li:</span></span><br><span class="line"><span class="string">    :param left:</span></span><br><span class="line"><span class="string">    :param right:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]</span><br><span class="line">    li[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">li1 = [<span class="number">15</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">19</span>]</span><br><span class="line">li2 = [<span class="number">100</span>, <span class="number">2</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">23</span>, <span class="number">76</span>, <span class="number">38</span>, <span class="number">85</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">li, low, mid, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将俩个排序好的列表，归并在一个，且排好顺序</span></span><br><span class="line"><span class="string">    :param li:</span></span><br><span class="line"><span class="string">    :param low:</span></span><br><span class="line"><span class="string">    :param mid:</span></span><br><span class="line"><span class="string">    :param high:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = low</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    li_tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt;= li[j]:  <span class="comment"># 排好序的左边和右边比较。如果小的先放入临时的列表</span></span><br><span class="line">            li_tmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 往后移动</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            li_tmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        li_tmp.append(li[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        li_tmp.append(li[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low, high + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        li[i] = li_tmp[i - low]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merege_sort</span>(<span class="params">li, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    递归的思想解决问题，类似汉罗塔问题</span></span><br><span class="line"><span class="string">    :param li: 待排序的列表</span></span><br><span class="line"><span class="string">    :param low:</span></span><br><span class="line"><span class="string">    :param high:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        merege_sort(li, low, mid)</span><br><span class="line">        merege_sort(li, mid + <span class="number">1</span>, high)</span><br><span class="line">        merge(li, low, mid, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># merege(li1, 0, 4, 8)</span></span><br><span class="line"><span class="comment"># print(li1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">merege_sort(li2, <span class="number">0</span>, <span class="built_in">len</span>(li2) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(li2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shift_down</span>(<span class="params">li, low, high</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    堆的调整(大根堆)</span></span><br><span class="line"><span class="string">    :param li: 树的根</span></span><br><span class="line"><span class="string">    :param low: 树的根的位置</span></span><br><span class="line"><span class="string">    :param high: 树的最后的一个节点的位置，表示数的范围</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tmp = li[low]  <span class="comment"># 把根的值用临时变量先存储</span></span><br><span class="line">    i = low  <span class="comment"># 拿出来之后，空位的位置</span></span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 俩个孩子的位置</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:  <span class="comment"># 循环退出的第二个条件：j&gt;high，说米i是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j + <span class="number">1</span>]:  <span class="comment"># 右孩子必须存在才能j+1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> li[j] &gt; tmp:</span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 循环退出的第一个条件：j位置的值比tmp小，说明俩个孩子都比tmp小</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># li = [2, 9, 7, 8, 5, 0, 1, 6, 4, 3]</span></span><br><span class="line"><span class="comment"># shift_down(li, 0, len(li)-1)</span></span><br><span class="line"><span class="comment"># print(li)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_heap</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    堆排序</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="comment"># 1.从最后的节点位置开始构造堆，low = (n - 1 - 1) // 2, high = n - 1</span></span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        shift_down(li, low, n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">li</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    build_heap(li)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">        shift_down(li, <span class="number">0</span>, high - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10000</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">heap_sort(li)</span><br><span class="line"><span class="comment"># print(li)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>·</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.idesperado.com">Jane</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.idesperado.com/post/5fbea8d0.html">http://www.idesperado.com/post/5fbea8d0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.idesperado.com" target="_blank">desperado</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/extra_imgs/town.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/cd83947e.html" title="js的hook方法和技巧"><img class="cover" src="/extra_imgs/town.jpg" onerror="onerror=null;src='/img/unfind.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">js的hook方法和技巧</div></div></a></div><div class="next-post pull-right"><a href="/post/6846cc9a.html" title="初识websocket"><img class="cover" src="/extra_imgs/town.jpg" onerror="onerror=null;src='/img/unfind.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">初识websocket</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img2.baidu.com/it/u=4274118481,3879373441&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=400&amp;h=400" onerror="this.onerror=null;this.src='/img/unfind.jpg'" alt="avatar"/></div><div class="author-info__name">Jane</div><div class="author-info__description">We think too much and feel too little. More than machinery we need humanity!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">28</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zhang-Jane"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Zhang-Jane" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:luckingshine@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Epython%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88"><span class="toc-number">1.</span> <span class="toc-text">关于python后端开发工程师</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Epython%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">关于python相关面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#python%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">python基础相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">python基础的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">3.1.1.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%A5%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">元祖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">3.1.3.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">出题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">关于定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">关于操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">关于函数传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">关于生成器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">Python 直接赋值、浅拷贝和深度拷贝解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB-class-%E5%92%8C%E5%85%83%E7%B1%BB-metaclass-%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">类 class 和元类 metaclass 的有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">实例方法、类方法和静态方法有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84-property-%E5%B1%9E%E6%80%A7%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">类中的 property 属性有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%94%AF%E6%8C%81%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">类如何才能支持比较操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hasattr-%E3%80%81getattr-%E3%80%81setattr-%E3%80%81delattr-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">hasattr()、getattr()、setattr()、delattr()分别有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%8F%AA%E9%9C%80%E8%AF%BB%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%96%E8%80%85%E9%81%BF%E5%85%8D%E8%AF%BB%E5%8F%96%E6%97%B6%E5%80%99%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">大文件只需读取部分内容，或者避免读取时候内存不足的解决方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9Fwith-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">什么是上下文？with 上下文管理器原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E7%BC%93%E5%86%B2%E3%80%81%E8%A1%8C%E7%BC%93%E5%86%B2%E5%92%8C%E6%97%A0%E7%BC%93%E5%86%B2%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">什么是全缓冲、行缓冲和无缓冲？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9FJSON-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">什么是序列化和反序列化？JSON 序列化时常用的四个函数是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">Python 的内存管理机制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93%EF%BC%8Cxpath%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">常用库，xpath，正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.13.1.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#match%E3%80%81search-%E5%92%8C-findall-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.13.1.0.1.</span> <span class="toc-text">match、search 和 findall 有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84-%E3%80%81-%E3%80%81-%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">3.13.2.</span> <span class="toc-text">正则表达式的 ()、[]、{} 分别代表什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84-%E3%80%81-%E3%80%81-%E3%80%81-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.13.3.</span> <span class="toc-text">正则表达式中的 .\*、.+、.\*?、.+? 有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">http协议相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-0%E5%92%8C1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">HTTP1.0和1.1的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scrapy%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="toc-number">5.</span> <span class="toc-text">scrapy的框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">基本组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scrapy-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%BB%E9%87%8D%E7%9A%84%EF%BC%9F%E6%8C%87%E7%BA%B9%E5%8E%BB%E9%87%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">Scrapy 是如何实现去重的？指纹去重是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scrapy-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">Scrapy 项目中的常用命令有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B-Scrapy-%E7%88%AC%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">描述一下 Scrapy 爬取一个网站的工作流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spider%E3%80%81CrawlSpider%E3%80%81XMLFeedSpider-%E5%92%8C-RedisSpider-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">Spider、CrawlSpider、XMLFeedSpider 和 RedisSpider 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scrapy%E5%A6%82%E4%BD%95%E7%88%AC%E5%8F%96%E5%B1%9E%E6%80%A7%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2%E7%9A%84item%E5%91%A2"><span class="toc-number">5.6.</span> <span class="toc-text">Scrapy如何爬取属性在不同页面的item呢</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scrapy%E7%88%AC%E8%99%AB%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2-x2F-%E5%86%85%E5%AD%98%E7%88%86%E4%BA%86-x2F-%E6%A0%88%E6%BA%A2%E5%87%BA%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">5.7.</span> <span class="toc-text">Scrapy爬虫有内存泄露&#x2F;内存爆了&#x2F;栈溢出了，怎么办?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookiejar%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">5.8.</span> <span class="toc-text">cookiejar使用以及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ItemLoader%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">ItemLoader的用法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">kafka消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">关系型数据库和非关系型数据库的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.0.1.</span> <span class="toc-text">关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E7%82%B9"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">关系型数据库优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%BA%E7%82%B9"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">关系型数据库缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.0.2.</span> <span class="toc-text">非关系型数据库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql%EF%BC%8Credis"><span class="toc-number">8.</span> <span class="toc-text">Mysql，redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql"><span class="toc-number">8.1.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Innodb%E5%92%8CMyisam%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.1.1.</span> <span class="toc-text">Innodb和Myisam的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">8.1.2.</span> <span class="toc-text">事务四大特性（ACID）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9A"><span class="toc-number">8.1.3.</span> <span class="toc-text">三范式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E8%AF%AD%E5%8F%A5%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">8.1.4.</span> <span class="toc-text">SQL 语句主要有哪些？分别有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.5.</span> <span class="toc-text">什么是索引？索引的优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%EF%BC%9F%E8%A7%86%E5%9B%BE%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">8.1.6.</span> <span class="toc-text">什么是视图？视图有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C-SQL-%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">8.1.7.</span> <span class="toc-text">如何进行 SQL 优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">8.2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">8.2.1.</span> <span class="toc-text">Redis 常见数据类型有哪些？各自有什么应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.2.</span> <span class="toc-text">Redis 的事务是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">redis 有哪几种数据淘汰策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89-Key-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.2.4.</span> <span class="toc-text">如何解决 Redis 的并发竞争 Key 的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">8.2.5.</span> <span class="toc-text">什么是分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">8.2.6.</span> <span class="toc-text">Python 如何实现一个 Redis 分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">布隆过滤原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">9.0.1.</span> <span class="toc-text">存入过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#frida%E5%92%8Cxposed%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">frida和xposed的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Xposed-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">11.0.1.</span> <span class="toc-text">Xposed 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frida%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">11.0.2.</span> <span class="toc-text">frida注入原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1"><span class="toc-number">12.0.1.</span> <span class="toc-text">冒泡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">12.0.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.5.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.6.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">12.0.7.</span> <span class="toc-text">堆排序</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/80db8027.html" title="go语言基础">go语言基础</a><time datetime="2023-02-05T07:50:08.000Z" title="发表于 2023-02-05 15:50:08">2023-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/897196e0.html" title="日常使用的工具">日常使用的工具</a><time datetime="2023-02-05T07:39:33.000Z" title="发表于 2023-02-05 15:39:33">2023-02-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/b3a6abb4.html" title="线程和进程">线程和进程</a><time datetime="2023-01-26T13:57:12.000Z" title="发表于 2023-01-26 21:57:12">2023-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/bbdeeae3.html" title="IDA手册">IDA手册</a><time datetime="2023-01-24T14:51:47.000Z" title="发表于 2023-01-24 22:51:47">2023-01-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3ad834c9.html" title="zookeeper">zookeeper</a><time datetime="2022-12-25T15:25:46.000Z" title="发表于 2022-12-25 23:25:46">2022-12-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/extra_imgs/town.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jane</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="43049" data-server="netease" data-type="album" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>