---
title: 线程和进程
abbrlink: b3a6abb4
date: 2023-01-26 21:57:12
tags:
---
## 基本介绍
1.进程：可以理解为：你运行一个python程序，最终“进程已结束，退出代码 0”，
就是该python程序所有的内容执行完毕。
2.主线程：应用程序运行即为主线程（从程序第一行到最后一行执行完毕，
中间遇到子线程的start,子线程去执行它的函数，主线程继续往下执行其他语句）
3.用户线程（子线程）：在主线程中可以创建和启动新线程，默认为用户线程（子线程）
4.daemon线程：守护线程，设置子线程为守护线程时，主线程一旦执行结束，则全部线程全部被终止执行，可能出现的情况就是，子线程的任务还没有完全执行结束，就被迫停止。t.daemon 属性，设置为True，则为daemon线程，必须在start()之前调用
5.join：所有的子线程都执行完成再结束主线程，此时需要用到join()


```python
import threading
import time
import sys
import os


class MyThreadDaemon(threading.Thread):
    def __init__(self, n):
        threading.Thread.__init__(self)
        self.n = n

    def demo(self):
        t = threading.current_thread()
        print(f'线程{t.name} -- {t} 开始')
        for i in range(10):
            time.sleep(self.n)
            print(f'daemon线程{t.name} -- {t} 正在运行')
        # 执行不到哦 主线程结束后进程不等待守护线程完成，立即结束
        print(f'daemon线程{t.name} -- {t} 结束')

    def run(self):
        self.demo()


def mytest():
    print(f'主线程开始 {threading.current_thread()}')
    t = MyThreadDaemon(1)  # 创建子线程
    t.name = 'daemon'
    t.daemon = True  # 设置为守护线程
    t.start()
    time.sleep(2)  # 延时2秒，print('主线程结束')主线程语句延迟2秒执行即主线程延迟2秒结束，期间守护线程‘正在运行’
    print(f'主线程结束 {threading.current_thread()}')  # 此语句执行完毕后主线程结束，守护线程立即停止


def fun():
    print(f'线程 {threading.current_thread()} 正在运行')
    print("start fun")
    time.sleep(2)
    print("end fun")


def mytest2():
    print(f"main thread {threading.current_thread()}")
    t1 = threading.Thread(target=fun, args=())
    t1.setDaemon(False)
    t1.start()
    t1.join()
    time.sleep(1)
    print(f"main thread end {threading.current_thread()}")


def mytest3():
    print(f"main thread is {threading.current_thread()}")
    event = threading.Event()
    thread = threading.Thread(target=f, args=(event,))
    thread.start()
    try:
        while 1:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Ctrl+C pressed...")
        event.set()  # notify the child thread to exit
        sys.exit(1)
    print("main thread end")


def f(event):
    print(f"son thread is {threading.current_thread()}")
    while not event.is_set():
        time.sleep(2)
        print(1)  # do the actual work


if __name__ == '__main__':
    mytest3()


```

```python
from multiprocessing import Process
import threading
import time
import sys
import os
import signal


def run_proc(name):
    pid = os.getpid()
    print(f'子进程开始 {name}--{pid}...')
    print(f"{pid}的主线程开始 {threading.current_thread()}")

    time.sleep(10)

    print(f'子进程结束 {name}--{pid}...')
    print(f"{pid}的主线程结束 {threading.current_thread()}")


def term(sig_num, addtion):

    print('current pid is %s, group id is %s' % (os.getpid(), os.getpgrp()))

    os.kill(os.getpid(), signal.SIGKILL)


def main():
    main_pid = os.getpid()
    print(f'主进程开始: {Process.name} -- {main_pid}')
    print(f"{main_pid}的线程开始 {threading.current_thread()}")
    p = Process(target=run_proc, args=('test',))
    p.start()
    p.join()
    print(f"{main_pid}的线程结束 {threading.current_thread()}")
    print(f'主进程结束: {Process.name} -- {main_pid}')


if __name__ == '__main__':
    main()
```

## Windows11工具
https://learn.microsoft.com/en-us/sysinternals/downloads/pslist
pslist -dmx <pid>

## 变量共享
```python
from multiprocessing import Process
import threading
import os

a = 1


def add(a):
    a += 100
    print(f"add a is {a}")


def calculator(name):
    # 创建的一个新的进程
    global a
    a += 1
    # 结果 a = 2
    print(f"calculator a is {a}")
    t1 = threading.Thread(target=add, args=(a, ))
    t1.start()
    a += 1
    # 结果 a = 3
    t2 = threading.Thread(target=add, args=(a, ))
    t2.start()


def main():
    # simple_cal()
    p = Process(target=calculator, args=('test',))
    p.start()
    p.join()


def simple_cal():
    global a
    a += 1


if __name__ == '__main__':
    main()
    print(f"main a is {a}")

```

```python
from multiprocessing import Process
import threading
import os

a = 0


def add():
    global a
    for _ in range(10):
        a += 1
        print(f"add a is {a}")


def calculator(name):
    # 创建的一个新的进程
    # 结果 a = 2

    t1 = threading.Thread(target=add)
    t1.start()
    t1.join()
    # 结果 a = 3
    t2 = threading.Thread(target=add)
    t2.start()
    t2.join()
    p = Process(target=add)
    p.start()
    p.join()


def main():
    # simple_cal()
    p = Process(target=calculator, args=('test',))
    p.start()
    p.join()


def simple_cal():
    global a
    a += 1


if __name__ == '__main__':
    main()
    print(f"main a is {a}")
```